<?php
/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
/**
 * Movie_HelioviewerMovie Class Definition
 *
 * PHP version 5
 *
 * @category Movie
 * @package  Helioviewer
 * @author   Keith Hughitt <keith.hughitt@nasa.gov>
 * @author   Jaclyn Beck <jaclyn.r.beck@gmail.com>
 * @license  http://www.mozilla.org/MPL/MPL-1.1.html Mozilla Public License 1.1
 * @link     http://launchpad.net/helioviewer.org
 */
require_once 'src/Image/Composite/HelioviewerMovieFrame.php';
require_once 'src/Helper/DateTimeConversions.php';
require_once 'src/Database/ImgIndex.php';
require_once 'src/Movie/FFMPEGEncoder.php';
/**
 * Represents a static (e.g. mp4/webm) movie generated by Helioviewer
 *
 * Note: For movies, it is easiest to work with Unix timestamps since that is what is returned
 *       from the database. To get from a javascript Date object to a Unix timestamp, simply
 *       use "date.getTime() * 1000." (getTime returns the number of miliseconds)
 *
 * @category Movie
 * @package  Helioviewer
 * @author   Keith Hughitt <keith.hughitt@nasa.gov>
 * @author   Jaclyn Beck <jaclyn.r.beck@gmail.com>
 * @license  http://www.mozilla.org/MPL/MPL-1.1.html Mozilla Public License 1.1
 * @link     http://launchpad.net/helioviewer.org
 */
class Movie_HelioviewerMovie
{
    protected $id;
    protected $frameRate;
    protected $numFrames;
    protected $startDate;
    protected $endDate;
    protected $directory;
    protected $filename;
    private $_db;
    private $_options;
    private $_layers;
    private $_roi;
    private $_startTimestamp;
    private $_endTimestamp;
    private $_frames = array();

    
    /**
     * Prepares the parameters passed in from the api call and makes a movie from them.
     *
     * @return {String} a url to the movie, or the movie will display.
     */
    public function __construct($id, $layers, $startDateString, $endDateString, $roi, $options)
    {
        $defaults = array(
            'format'    => "mp4",
            'frameRate' => false,
            'maxFrames' => HV_MAX_MOVIE_FRAMES,
            'watermark' => true
        );
        $this->_options = array_replace($defaults, $options);
        
        $this->id         = $id;

        $this->_db        = new Database_ImgIndex();
        $this->_layers    = $layers;
        $this->_roi       = $roi;
        
        $this->startDate = $startDateString;
        $this->endDate   = $endDateString;
    }
    
    /**
     * Cancels movie request
     * 
     * @param string $msg Error message
     */
    private function _abort($msg) {
        $this->_db->markMovieAsInvlid($this->_id);
        throw new Exception("Unable to create movie: " . $msg, 1);
    }
    
    /**
     * Determines the directory to store the movie in.
     * 
     * @return string Directory
     */
    private function _buildDir ()
    {
        return sprintf("%s/movies/%s/%s/", HV_CACHE_DIR, date("Y/m/d"), $this->id);
    }

    /**
     * Determines filename to use for the movie
     * 
     * @param string $extension Extension of the movie format to be created 
     *
     * @return string Movie filename
     */
    private function _buildFilename($extension) {
        $start = str_replace(array(":", "-", "T", "Z"), "_", $this->startDate);
        $end   = str_replace(array(":", "-", "T", "Z"), "_", $this->endDate);

        return sprintf("%s_%s_%s.%s", $start, $end, $this->_layers->toString(), $extension);
    }

    /**
     * Takes in meta and layer information and creates movie frames from them.
     * 
     * TODO: Use middle frame instead last one...
     * TODO: Create standardized thumbnail sizes (e.g. thumbnail-med.png = 480x320, etc)
     *
     * @param {String} $tmpDir     the directory where the frames will be stored
     *
     * @return $images an array of built movie frames
     */
    private function _buildMovieFrames($watermark)
    {
        $frameNum = 0;

        // Movie frame parameters
        $options = array(
            'database'   => $this->_db,
            'compress'   => false,
            'interlace'  => false,
            'watermark'=> $watermark
        );

        // Compile frames
        foreach ($this->_timestamps as $time) {
            $filepath =  sprintf("%s/frames/frame%d.bmp", $this->directory, $frameNum);

            try {
	            $screenshot = new Image_Composite_HelioviewerMovieFrame($filepath, $this->_layers, $time, $this->_roi, $options);
	            $frameNum++;
	            array_push($this->_frames, $filepath);
            } catch (Exception $e) {
            	$this->numFrames--; // Recover if failure occurs on a single frame
            }
        }
        
        // Create preview image
        $preview = $screenshot->getIMagickImage();
        $preview->setImageCompression(IMagick::COMPRESSION_LZW);
        $preview->setImageCompressionQuality(PNG_LOW_COMPRESSION);
        $preview->setInterlaceScheme(IMagick::INTERLACE_PLANE);
        $preview->writeImage($this->directory . "/" . $this->filename . ".png");
        $preview->destroy();
    }

    /**
     * Uses numFrames to calculate the frame rate that should
     * be used when encoding the movie.
     *
     * @return Int optimized frame rate
     */
    private function _determineOptimalFrameRate($requestedFrameRate)
    {
        // Subtract 1 because we added an extra frame to the end
        $frameRate = ($this->numFrames - 1 ) / HV_DEFAULT_MOVIE_PLAYBACK_IN_SECONDS;

        // Take the smaller number in case the user specifies a larger frame rate than is practical.
        if ($requestedFrameRate) {
            $frameRate = min($frameRate, $requestedFrameRate);
        }

        return max(1, $frameRate);
    }

    /**
     * Builds the requested movie
     *
     * Makes a temporary directory to store frames in, calculates a timestamp for every frame, gets the closest
     * image to each timestamp for each layer. Then takes all layers belonging to one timestamp and makes a movie frame
     * out of it. When done with all movie frames, phpvideotoolkit is used to compile all the frames into a movie.
     *
     * @return void
     */
    private function _buildMovie()
    {
        // Create and FFmpeg encoder instance
        $ffmpeg = new Movie_FFMPEGEncoder($this->frameRate);
        
        // Create a high-quality H.264 video using an MPEG-4 (mp4) container format
        $ffmpeg->createVideo($this->directory, $this->filename . "-hq", "mp4", $this->_width, $this->_height, "ultrafast", 15);

        // Create a medium-quality H.264 video using an MPEG-4 (mp4) container format
        $ffmpeg->createVideo($this->directory, $this->filename, "mp4", $this->_width, $this->_height);

        //Create alternative container format options for medium-quality video (.flv)
        $ffmpeg->createAlternativeVideoFormat($this->directory, $this->filename, "mp4", "flv");
    }
    
    /**
     * Returns an array of the timestamps for the key movie layer
     * 
     * For single layer movies, the number of frames will be either HV_MAX_MOVIE_FRAMES, or the number of
     * images available for the requested time range. For multi-layer movies, the number of frames included
     * may be reduced to ensure that the total number of SubFieldImages needed does not exceed HV_MAX_MOVIE_FRAMES
     */
    private function _getTimeStamps()
    {
        $layerCounts = array();

        // Determine the number of images that are available for the request duration for each layer
        foreach ($this->_layers->toArray() as $layer) {
            $n = $this->_db->getImageCount($this->startDate, $this->endDate, $layer['sourceId']);
            $layerCounts[$layer['sourceId']] = $n;
        }

        // Choose the maximum number of frames that can be generated without exceeded the server limits defined
        // by HV_MAX_MOVIE_FRAMES
        $numFrames       = 0;
        $imagesRemaining = $this->_options['maxFrames'];
        $layersRemaining = $this->_layers->length();
        
        // Sort counts from smallest to largest
        asort($layerCounts);
        
        // Determine number of frames to create
        foreach($layerCounts as $dataSource => $count) {
            $numFrames = min($count, ($imagesRemaining / $layersRemaining));
            $imagesRemaining -= $numFrames;
            $layersRemaining -= 1;
        }
        
        // Number of frames to use
        $numFrames = floor($numFrames);

        // Get the entire range of available images between the movie start and end time 
        $entireRange = $this->_db->getImageRange($this->startDate, $this->endDate, $dataSource);
        
        // Sub-sample range so that only $numFrames timestamps are returned
        $timestamps = array();
        for ($i = 0; $i < $numFrames; $i++) {
            $index = round($i * (sizeOf($entireRange) / $numFrames));
            array_push($timestamps, $entireRange[$index]['date']);
        }
        return $timestamps;        
    }

    /**
     * Determines dimensions to use for movie and stores them
     * 
     * @return void
     */
    private function _setMovieDimensions() {
        $this->_width  = round($this->_roi->getPixelWidth());
        $this->_height = round($this->_roi->getPixelHeight());

        // Width and height must be divisible by 2 or ffmpeg will throw an error.
        if ($this->_width % 2 === 1) {
            $this->_width += 1;
        }
        
        if ($this->_height % 2 === 1) {
            $this->_height += 1;
        } 
    }

    /**
     * Adds black border to movie frames if neccessary to guarantee a 16:9 aspect ratio
     *
     * Checks the ratio of width to height and adjusts each dimension so that the
     * ratio is 16:9. The movie will be padded with a black background in JP2Image.php
     * using the new width and height.
     *
     * @return array Width and Height of padded movie frames
     */
    private function _setAspectRatios()
    {
        $width  = $this->_roi->getPixelWidth();
        $height = $this->_roi->getPixelHeight();

        $ratio = $width / $height;

        // Commented out because padding the width looks funny.
        /*
        // If width needs to be adjusted but height is fine
        if ($ratio < 16/9) {
        $adjust = (16/9) * $height / $width;
        $width *= $adjust;
        }
        */
        // Adjust height if necessary
        if ($ratio > 16/9) {
            $adjust = (9/16) * $width / $height;
            $height *= $adjust;
        }

        $dimensions = array("width" => $width, "height" => $height);
        return $dimensions;
    }
    
    /**
     * Build the movie frames and movie
     */
    public function build()
    {
        set_time_limit(180); // Extend time limit to avoid timeouts
        
        $this->directory = $this->_buildDir();
        $this->filename  = $this->_buildFilename($this->_options['format']);
        
        // Also store as timestamps
        $this->_startTimestamp = toUnixTimestamp($this->startDate);
        $this->_endTimestamp   = toUnixTimestamp($this->endDate);

        // Get timestamps for frames in the key movie layer
        $this->_timestamps = $this->_getTimeStamps();

        $this->numFrames = sizeOf($this->_timestamps);

        if ($this->numFrames == 0) {
            $this->_abort("No images available for the requested time range");
        }
        
        $this->frameRate = $this->_determineOptimalFrameRate($this->_options['frameRate']);

        $this->_setMovieDimensions();
        
        // Update movie entry in database with new details
        $this->_db->storeMovieProperties(
            $this->id, isoDateToMySQL($this->startDate), isoDateToMySQL($this->endDate),
            $this->numFrames, $this->frameRate, $this->_width, $this->_height
        );
        
        // Build movie frames
        $this->_buildMovieFrames($this->_options['watermark']);

        // Compile movie
        $this->_buildMovie();
        
        // Make as complete
        $this->_db->markMovieAsFinished($this->id);
    }
    
    /**
     * Returns the base filepath for movie without any file extension
     */
    public function getFilepath()
    {
        return $this->directory . "/" . $this->filename;
    }
    
    public function getDuration()
    {
        return $this->numFrames / $this->frameRate;
    }
    
    /**
     * Returns HTML for a video player with the requested movie loaded
     */
    public function getMoviePlayerHTML()
    {
        $filepath = str_replace(HV_ROOT_DIR, "../", $this->getFilepath());
        $css      = "width: {$this->_width}px; height: {$this->_height}px;";
        $duration = $this->numFrames / $this->frameRate;
        ?>
<!DOCTYPE html> 
<html> 
<head> 
    <title>Helioviewer.org - <?php echo $this->filename;?></title>            
    <script type="text/javascript" src="http://html5.kaltura.org/js"></script> 
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.js" type="text/javascript"></script>
</head> 
<body>
<div style="text-align: center;">
    <div style="margin-left: auto; margin-right: auto; <?php echo $css;?>";>
        <video style="margin-left: auto; margin-right: auto;" poster="<?php echo "$filepath.bmp"?>" durationHint="<?php echo $duration?>">
            <source src="<?php echo "$filepath.mp4"?>" /> 
            <source src="<?php echo "$filepath.mov"?>" />
            <source src="<?php echo "$filepath.flv"?>" /> 
        </video>
    </div>
</div>
</body> 
</html> 
        <?php        
    }
    
    /**
     * Returns the movie's current status
     * 
     * @return string The current movie status. Possible values include: QUEUED, PROCESSING, FINISHED
     */
    public function getStatus() 
    {
        return $this->_db->getMovieStatus($this->id);
    }    
    
    /**
     * Returns the Base URL to the most recently created movie (without a file extension)
     */
    public function getURL()
    {
        return str_replace(HV_ROOT_DIR, HV_WEB_ROOT_URL, $this->getFilepath());
    }
    
    /**
     * Destructor
     * 
     * @return void
     */
    public function __destruct()
    {
        // Clean up movie frame images that are no longer needed
        foreach ($this->_frames as $image) {
            if (file_exists($image)) {
                unlink($image);
            }
        }
        if (file_exists($this->directory . "/frames")) {
            rmdir($this->directory . "/frames");    
        }
    }
}
?>
